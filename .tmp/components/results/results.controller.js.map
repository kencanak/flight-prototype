{"version":3,"sources":["components/results/results.controller.js"],"names":["ResultsController","$state","$scope","Trips","errors","results","minDate","Date","allTrips","tripDetails","from","fromCode","to","toCode","return","departDate","returnDate","moment","add","toDate","passengers","priceMax","self","get","$promise","then","response","data","$on","event","angular","copy","queryTrips","departTrips","filter","searchFilter","returnTrips","length","i","tmp","depart","tmpPrice","parseInt","price","j","push","travelDate","filterFn","trip","validTrip","compareDate","timings","day","airport_details","setHours","$emit","date","format","module","controller"],"mappings":"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","file":"results.controller.js","sourcesContent":["'use strict';\n\nclass ResultsController {\n  constructor($state, $scope, Trips) {\n    this.errors = {};\n    this.$state = $state;\n    this.$scope = $scope;\n    this.results = [];\n    this.minDate = new Date();\n    this.Trips = Trips;\n    this.allTrips = [];\n    this.tripDetails = {\n      from: '',\n      fromCode: '',\n      to: '',\n      toCode: '',\n      return: true,\n      departDate: this.minDate,\n      returnDate: moment(this.minDate).add(5, 'days').toDate(),\n      passengers: 1,\n      priceMax: 200\n    };\n  }\n\n  $onInit() {\n    var self = this;\n\n    //let's grab all the trips data on load and cache it, by right shouldn't need this, if we have rest api\n    self.Trips.get().$promise.then(response => {\n      self.allTrips = response.data;\n    });\n\n    //receiving new search query event\n    self.$scope.$on('new-search', function (event, data) {\n      if (data) {\n        if (!data.fromCode && !data.toCode && !data.departDate) {\n          return false;\n        }\n        self.results = [];\n        angular.copy(data, self.tripDetails);\n        self.queryTrips();\n      }\n    });\n  }\n\n  queryTrips() {\n    var self = this;\n\n    //get possible trips with depart criteria\n    var departTrips = self.allTrips.filter( self.searchFilter(self.tripDetails.departDate, self.tripDetails.fromCode, self.tripDetails.toCode) );\n\n    var returnTrips = [];\n\n    //if it's a return trip, let's grab the possible trips with return criteria\n    if (self.tripDetails.return) {\n      returnTrips = self.allTrips.filter( self.searchFilter(self.tripDetails.returnDate, self.tripDetails.toCode, self.tripDetails.fromCode) );\n    }\n\n    //massaging the result data, to standardize the schema, and to permutate the possibility of timeslots and re calc the price limit if it's a return trip\n    //if it's a return trip, but there is no possible trip for depart trip, we will skip the following process\n    if (departTrips.length > 0) {\n      for (var i=0; i<departTrips.length; i++) {\n        var tmp = {};\n\n        tmp.depart = departTrips[i];\n        var tmpPrice = parseInt(tmp.depart.price);\n\n        //if it's a return trip, but there is no possible trip for return trip, we will break the loop\n        if (self.tripDetails.return && returnTrips.length === 0) {\n          break;\n        }\n\n        for (var j=0; j<returnTrips.length; j++) {\n          tmp.return = returnTrips[j];\n          tmpPrice += parseInt(tmp.return.price);\n        }\n\n        tmp.price = tmpPrice;\n\n        //only need to re-calc if it's return\n        if ((self.tripDetails.return && tmpPrice <= self.tripDetails.priceMax) || !self.tripDetails.return) {\n          self.results.push(tmp);\n        }\n      }\n    }\n  }\n\n  /* this is for filtering trip with trip query conditions*/\n  searchFilter(travelDate, from, to) {\n    var self = this;\n\n    return function filterFn(trip) {\n      var validTrip = self.compareDate(trip.timings.day, travelDate) &&\n                        trip.airport_details.from === from && trip.airport_details.to === to &&\n                        parseInt(trip.price) <= self.tripDetails.priceMax;\n\n      return validTrip;\n    };\n  }\n\n  //to compare the equal date, ignoring time\n  compareDate(from, to) {\n    from = moment(from).toDate().setHours(0, 0, 0, 0);\n    to = moment(to).toDate().setHours(0, 0, 0, 0);\n    return from === to;\n  }\n\n\n  newSearch() {\n    this.$scope.$emit('new-search', null);\n  }\n\n  formatDate(date) {\n    return moment(date).format('DD MMM YYYY');\n  }\n}\n\nangular.module('thoughtworksTestApp')\n  .controller('ResultsController', ResultsController);\n"]}